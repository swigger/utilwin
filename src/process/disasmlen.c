#include <stdint.h>
#include "disasmlen.h"

#ifndef __cplusplus
typedef _Bool bool;
#endif

/*
ref: http://ref.x86asm.net/coder64.html
ref: http://ref.x86asm.net/coder32.html
*/
/*
     // Using multi-bytes nops "0x0F 0x1F [address]" for Intel
     //  1: 0x90
     //  2: 0x66 0x90
     //  3: 0x66 0x66 0x90 (don't use "0x0F 0x1F 0x00" - need patching safe padding)
     //  4: 0x0F 0x1F 0x40 0x00
     //  5: 0x0F 0x1F 0x44 0x00 0x00
     //  6: 0x66 0x0F 0x1F 0x44 0x00 0x00
     //  7: 0x0F 0x1F 0x80 0x00 0x00 0x00 0x00
     //  8: 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00
     //  9: 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00
     // 10: 0x66 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00
     // 11: 0x66 0x66 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00
	 // The rest coding is Intel specific - don't use consecutive address nops
     // 12: 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x66 0x66 0x66 0x90
     // 13: 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x66 0x66 0x66 0x90
     // 14: 0x66 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x66 0x66 0x66 0x90
     // 15: 0x66 0x66 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x66 0x66 0x66 0x90
*/
#define b111000 0x38

static int set_bad_instruction(uint8_t * ptr, uint32_t * flags)
{
	*flags |= ILF_INVALID;
	return 1;
}

#if 0
// 16bit mode, not used.
static uint8_t get_modrm16(uint8_t v)
{
	//00xxx110
	if ((v & 0xC7)==0x6) return 2+1;
	if ((v&0xc0)==0x80) return 2+1;
	if ((v&0xc0)==0x40) return 1+1;
	return 1;
}
#endif

static uint8_t get_modrm(uint8_t v, uint8_t * psib)
{
	uint8_t sib = 0;
	uint8_t mode = v >> 6;
	//00xxx101  mode(2bit)+reg(3bit)+`R/M`(3bit)
	if ((v & 0xc7) == 0x5) return 4 + 1;
	if ((v & 0xc0) == 0xc0) return 1;
	if ((v & 0x7) == 0x4) sib = 1;
	if (mode == 2) return sib + 4 + 1;
	if (mode == 1) return sib + 1 + 1;
	if (mode == 0 && sib && (*psib & 0x7) == 5) return 4 + 1 + 1; //1byte modrm,1byte sib,4bytes disp.
	return sib + 1;
}

// table 0x80 means there is a modrm byte.
static uint8_t table1_ix86[256] = {
0x80,0x80,0x80,0x80,0x01,0x04,0x00,0x00,0x80,0x80,0x80,0x80,0x01,0x04,0x00,0x00,
0x80,0x80,0x80,0x80,0x01,0x04,0x00,0x00,0x80,0x80,0x80,0x80,0x01,0x04,0x00,0x00,
0x80,0x80,0x80,0x80,0x01,0x04,0x00,0x00,0x80,0x80,0x80,0x80,0x01,0x04,0x00,0x00,
0x80,0x80,0x80,0x80,0x01,0x04,0x00,0x00,0x80,0x80,0x80,0x80,0x01,0x04,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x80,0x80,0x00,0x00,0x00,0x00,0x04,0x84,0x01,0x81,0x00,0x00,0x00,0x00,
0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
0x81,0x84,0x81,0x81,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x00,0x00,
0x00,0x04,0x00,0x04,0x00,0x00,0x00,0x00,0x01,0x04,0x00,0x00,0x00,0x00,0x00,0x00,
0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,
0x81,0x81,0x02,0x00,0x80,0x80,0x81,0x84,0x03,0x00,0x02,0x00,0x00,0x01,0x00,0x00,
0x80,0x80,0x80,0x80,0x01,0x01,0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x04,0x04,0x06,0x01,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,
};
static uint8_t table2_ix86[256]={
0x80,0x80,0x80,0x80,0xFF,0xFF,0x00,0xFF,0x00,0x00,0xFF,0x00,0xFF,0x00,0xFF,0xFF,
0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
0x80,0x80,0x80,0x80,0xFF,0xFF,0xFF,0xFF,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x80,0xFF,0x81,0xFF,0xFF,0xFF,0xFF,0xFF,
0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
0x81,0x81,0x81,0x81,0x80,0x80,0x80,0x00,0x80,0x80,0xFF,0xFF,0x80,0x80,0x80,0x80,
0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,
0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
0x00,0x00,0x00,0x80,0x81,0x80,0xFF,0xFF,0x00,0x00,0x00,0x80,0x81,0x80,0x80,0x80,
0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x81,0x80,0x80,0x80,0x80,0x80,
0x80,0x80,0x81,0x80,0x81,0x81,0x81,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0xFF,
};

static int get_instruction_length_ix86_(uint8_t * ptr, int prefixcnt, bool bit16, unsigned int * flags)
{
	uint8_t op = *ptr;
	uint8_t v,addlen;

	if (prefixcnt >= 4)
	{
		//WTF???
		return 1;
	}

	switch (op)
	{
	case 0x26:
	case 0x2E:
	case 0x36:
	case 0x3E:
	case 0x64:
	case 0x65:
	case 0x67:
	case 0x9B:
	case 0xF0:
	case 0xF2:
	case 0xF3:
		return get_instruction_length_ix86_(ptr + 1, prefixcnt + 1, bit16, flags);
	case 0x66:
		return get_instruction_length_ix86_(ptr + 1, prefixcnt + 1, bit16, flags);
	case 0x0f:
		{
			v = table2_ix86[ptr[1]]; if (v == 0xff) return set_bad_instruction(ptr, flags);
			addlen = v & 0xf; if (addlen == 4 && bit16) addlen = 2;
			uint8_t modrmadd = (v & 0x80) ? get_modrm(ptr[2], ptr + 3) : 0;
			*flags |= (uint8_t)prefixcnt;
			*flags |= ILF_2BYTE;
			*flags |= modrmadd << ILF_MODRM_SHIFT;
			return prefixcnt + 2 + modrmadd + addlen;
		}
	default:
		{
			v = table1_ix86[op]; if (v == 0xff) return set_bad_instruction(ptr, flags);
			addlen = v & 0xf;
			if (op == 0xf6 && (ptr[1] & b111000) < 0x10) addlen = 1;
			if (op == 0xf7 && (ptr[1] & b111000) < 0x10) addlen = 4;
			if (addlen >= 4 && bit16) addlen -= 2;
			uint8_t modrmadd = (v & 0x80) ? get_modrm(ptr[1], ptr + 2) : 0;
			*flags |= (uint8_t)prefixcnt;
			*flags |= modrmadd << ILF_MODRM_SHIFT;
			return prefixcnt + 1 + modrmadd + addlen;
		}
	}
}

extc int get_instruction_length_ix86(const uint8_t * ptr, unsigned int * flags)
{
	unsigned int tmp = 0;
	if (flags)*flags = 0;
	return get_instruction_length_ix86_((uint8_t*)ptr, 0, 0, flags ? flags : &tmp);
}

static uint8_t table1_amd64[256] = {
0x80,0x80,0x80,0x80,0x01,0x04,0xFF,0xFF,0x80,0x80,0x80,0x80,0x01,0x04,0xFF,0x00,
0x80,0x80,0x80,0x80,0x01,0x04,0xFF,0xFF,0x80,0x80,0x80,0x80,0x01,0x04,0xFF,0xFF,
0x80,0x80,0x80,0x80,0x01,0x04,0x00,0xFF,0x80,0x80,0x80,0x80,0x01,0x04,0x00,0xFF,
0x80,0x80,0x80,0x80,0x01,0x04,0x00,0xFF,0x80,0x80,0x80,0x80,0x01,0x04,0x00,0xFF,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xFF,0xFF,0xFF,0x80,0x00,0x00,0x00,0x00,0x04,0x84,0x01,0x81,0x00,0x00,0x00,0x00,
0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
0x81,0x84,0xFF,0x81,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x04,0x00,0x00,0x00,0x00,0x00,0x00,
0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
0x81,0x81,0x02,0x00,0xFF,0xFF,0x81,0x84,0x03,0x00,0x02,0x00,0x00,0x01,0x00,0x00,
0x80,0x80,0x80,0x80,0xFF,0xFF,0xFF,0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x04,0x04,0xFF,0x01,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,
};

static uint8_t table2_amd64[256] = {
0x80,0x80,0x80,0x80,0xFF,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0xFF,0x00,0xFF,0xFF,
0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
0x80,0x80,0x80,0x80,0xFF,0xFF,0xFF,0xFF,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x80,0xFF,0x81,0xFF,0xFF,0xFF,0xFF,0xFF,
0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
0x81,0x81,0x81,0x81,0x80,0x80,0x80,0x00,0x80,0x80,0xFF,0xFF,0x80,0x80,0x80,0x80,
0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,
0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
0x00,0x00,0x00,0x80,0x81,0x80,0xFF,0xFF,0x00,0x00,0x00,0x80,0x81,0x80,0x80,0x80,
0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x81,0x80,0x80,0x80,0x80,0x80,
0x80,0x80,0x81,0x80,0x81,0x81,0x81,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0xFF,
};

static int get_width_amd64(uint8_t * prefix, int n)
{
	int width = 0, i;
	for (i = 0; i < n; ++i)
	{
		uint8_t ch = prefix[i];
		if (ch == 0x66)
		{
			if (width == 0 || width == 16) width = 16;
			else return 0;
		}
		if ((ch & 0xf8) == 0x48)
		{
			if (width == 0) width = 64;
			else return 0;
		}
	}
	if (width == 0) width = 32;
	return width;
}

static int get_instruction_length_amd64_(uint8_t * ptr, int prefixcnt, unsigned int * flags)
{
	uint8_t op = *ptr;
	uint8_t v, modrmadd, addlen;

	if (prefixcnt >= 8)
	{
		//WTF???
		return 1;
	}

	switch (op)
	{
	case 0x26:
	case 0x2E:
	case 0x36:
	case 0x3E:
	case 0x40:
	case 0x41:
	case 0x42:
	case 0x43:
	case 0x44:
	case 0x45:
	case 0x46:
	case 0x47:
	case 0x64:
	case 0x65:
	case 0x66:
	case 0x67:
	case 0x9B:
	case 0xF0:
	case 0xF2:
	case 0xF3:
	case 0x48:
	case 0x49:
	case 0x4A:
	case 0x4B:
	case 0x4C:
	case 0x4D:
	case 0x4E:
	case 0x4F:
		return get_instruction_length_amd64_(ptr + 1, prefixcnt + 1, flags);
	case 0x0f:
		{
			int width = get_width_amd64(ptr - prefixcnt, prefixcnt);
			if (!width) return set_bad_instruction(ptr, flags);

			v = table2_amd64[ptr[1]]; if (v == 0xff) return set_bad_instruction(ptr, flags);
			modrmadd = 0;
			if (v & 0x80) {
				modrmadd = get_modrm(ptr[2], ptr + 3);
				if ((ptr[2] & 0xc7) == 0x5) *flags |= ILF_PC_RELA;
			}
			addlen = v & 0xf;
			if (addlen == 8 && width == 32)addlen = 4;
			else if (addlen == 8 && width == 16)addlen = 2;
			else if (addlen == 4 && width == 16)addlen = 2;
			*flags |= (uint8_t)prefixcnt;
			*flags |= ILF_2BYTE;
			*flags |= modrmadd << ILF_MODRM_SHIFT;
			return prefixcnt + 2 + modrmadd + addlen;
		}
	default:
		{
			int width = get_width_amd64(ptr - prefixcnt, prefixcnt);
			if (!width) return set_bad_instruction(ptr, flags);

			v = table1_amd64[op]; if (v == 0xff) return set_bad_instruction(ptr, flags);
			modrmadd = 0;
			if (v & 0x80) {
				modrmadd = get_modrm(ptr[1], ptr + 2);
				if ((ptr[1] & 0xc7) == 0x5) *flags |= ILF_PC_RELA;
			}
			addlen = v & 0xf;
			if (op == 0xf6 && (ptr[1] & b111000) < 0x10) addlen = 1;
			if (op == 0xf7 && (ptr[1] & b111000) < 0x10) addlen = 8;
			if (addlen == 8 && width == 32)addlen = 4;
			else if (addlen == 8 && width == 16)addlen = 2;
			else if (addlen == 4 && width == 16)addlen = 2;
			*flags |= (uint8_t)prefixcnt;
			*flags |= modrmadd << ILF_MODRM_SHIFT;
			return prefixcnt + 1 + modrmadd + addlen;
		}
	}
}

extc int get_instruction_length_amd64(const uint8_t * ptr, unsigned int * flags)
{
	unsigned int tmp = 0;
	if (flags)*flags = 0;
	return get_instruction_length_amd64_((uint8_t*)ptr, 0, flags ? flags : &tmp);
}

extc uint8_t * function_start(void * p)
{
	uint8_t * r = (uint8_t*)(p);
	for (;;)
	{
		if (*r == 0xe9)
			r = r + 5 + *(int*)(r + 1);
		else if (*(unsigned short*)r == 0x25ff)
		{
			int off = *(int*)(r + 2);
			uint8_t* base = sizeof(void*) == 8 ? (r + 6) : 0;
			r = *(uint8_t**)(base + off);
		}
#if defined(_M_AMD64) || defined(__x86_64__)
		else if (r[0] == 0x48 && r[1] == 0xff && r[2] == 0x25) {
			int off = *(int*)(r + 3);
			uint8_t* base = r + 7;
			r = *(uint8_t**)(base + off);
		}
#endif
		else
			break;
	}
	return r;
}
